---
title: "Final Roman Based Analysis"
author: "Juan P Barraza"
date: "9/28/2017"
output: html_document
---

```{r generalAnalysisSetup, include= FALSE, echo=FALSE, fig.width=9, fig.height=7, results='asis'}
library(rdist)
library(pixmap)
library(rtiff)
library(reshape2)
library(gplots)
library(dplyr)
library(gdata)
library(ggplot2)
library(cowplot)

#### 1. THE SETUP
rm(list = ls())
thresholdImage<-function(filesList,channel,side){
  c1 <- array(0, c(side, side, length(filesList)))
  for(i in 1:length(filesList)){
    print(paste("loading ch1...", i, "/", length(filesList), filesList[i]))
    c1[,,i]<-pixmap::getChannels(readTiff(filesList[i]), colors = channel)
  }
  c1_t <- array(0, c(side, side, length(filesList)))
  for(i in 1:dim(c1)[3]){
    print(paste("thresholding ch1...", i, "/", length(filesList), filesList[i]))
    th <- autoThreshold(c1[,,i], mean(c1[,,i]))[2]
    c1_t[,,i][c1[,,i] > th] <- 1 
  }
  return(c1_t)
}
CorrectSampleVolume<-function(thresholdedImage, xytotal, ztotal, xydim, zdim){#this limits the boundaries of voxel sampling to prevent going out of bounds
  correctedImage<- thresholdedImage[  thresholdedImage$x >= xydim & thresholdedImage$x <= (xytotal-xydim) &
                                        thresholdedImage$y >= xydim & thresholdedImage$y <= (xytotal-xydim) &
                                        thresholdedImage$z >= zdim & thresholdedImage$z <= (ztotal-zdim),]
  return(correctedImage)
}
IdVoxel<-function(thresholdedImage){#this makes a df with the coordinates from all voxel objects
  dfVoxelCoords <- data.frame(which(thresholdedImage == 1, T))
  colnames(dfVoxelCoords) <- c("x", "y", "z")
  return(dfVoxelCoords)
}
SampleVoxels<-function(voxelsCoords, sampleSize){#randomly samples non-empty voxels from a thresholded image
  sampledVoxels <- sample(1:dim(voxelsCoords)[1], size = sampleSize)
  sampleVoxelsCoords <- voxelsCoords[sampledVoxels,]
  return(sampleVoxelsCoords)
}

#Only one of the following 2 functions may be used, DistanceRadius has one extra line to filter out distances out of the radius
DistanceBox<-function(focus,thresholdedImage, xydim, zdim, xyscale, zscale){
  #takes a voxel and collects all the surrounding voxels within the specified box
  #input of xydim and zdim is in voxels
  outbox<-thresholdedImage[(focus$x-xydim):(focus$x+xydim), (focus$y-xydim):(focus$y+xydim), (focus$z-zdim):(focus$z+zdim)]
  outboxCoords<-(IdVoxel(outbox))#find non-empty voxels in box
  outboxCoords<-outboxCoords-1#move to the origin
  outboxCoords$x<-outboxCoords$x*xyscale#convert pixels to real lengths
  outboxCoords$y<-outboxCoords$y*xyscale
  outboxCoords$z<-outboxCoords$z*zscale
  distances<-as.data.frame(t(cdist(t(as.matrix(c(xydim*xyscale, xydim*xyscale, zdim*zscale))), as.matrix(outboxCoords))))
  return(distances)
}
DistanceRadius<-function(focus,thresholdedImage, xydim, zdim, xyscale, zscale){
  #takes a voxel and collects all the surrounding voxels within the specified sphere
  #input of xydim and zdim is in voxels
  #maximum distance allowed is capped at xydim*xyscale
  outbox<-thresholdedImage[(focus$x-xydim):(focus$x+xydim), (focus$y-xydim):(focus$y+xydim), (focus$z-zdim):(focus$z+zdim)]
  outboxCoords<-(IdVoxel(outbox))#find non-empty voxels in box
  outboxCoords<-outboxCoords-1#move to the origin
  outboxCoords$x<-outboxCoords$x*xyscale#convert pixels to real lengths
  outboxCoords$y<-outboxCoords$y*xyscale
  outboxCoords$z<-outboxCoords$z*zscale
  radius<-(((xydim*2)+1)/2)*xyscale
  distances<-as.data.frame(t(cdist(t(as.matrix(c(xydim*xyscale, xydim*xyscale, zdim*zscale))), as.matrix(outboxCoords))))
  if(nrow(distances)>0){#this prevents code from breaking if there are no pixels in vecinity
    distances<-subset(distances,!(distances[1]==0))#this removes the distance to self 
    }
  if(nrow(distances)>0){
    distances<-subset(distances,!(distances[1]>(radius)))#this filters out all the distances larger than the radius
  }
  #code crashes if you dont do independent "if statements"
  return(distances)
}
```

```{r firstAnalysisSetup, include= FALSE, echo=FALSE, fig.width=9, fig.height=7, results='asis'}
#The following 4 functions are the first iteration of the pipeline. These functions have a square as the search volume and only look at histogram density over total non-empty voxels, in other words the sumation of the final data adds up to one.
Binning<-function(dfDistances){#takes the list of pairwise distances between focus and object in box and outputs frequency density table binned by distances of 2 uM
  numDistances<-apply(dfDistances,1,as.numeric)#turn input df into numeric so hist() works
  bins<-seq(0, max(dfDistances)+2,2)#establish the binning
  histogram<-hist(numDistances, breaks = bins, plot = FALSE)
  densityTable<-as.data.frame(histogram$density*2)
  return(cbind(histogram$mids, densityTable))
}
LoopVoxels<-function(voxelsList, thresholdedImage, xyBoxDim, zBoxDim, xyScale, zScale ){
  loopBox<-list()
  for (i in 1:length(voxelsList[[1]])){
    loopBox[[i]]<-Binning(DistanceBox(voxelsList[i,],thresholdedImage, xyBoxDim, zBoxDim, xyScale, zScale))
  }
  return(loopBox)
}
MergeStats<-function(dataList){
  mergeLoop<-Reduce(function(dtf1,dtf2) merge(dtf1,dtf2, by= "histogram$mids",all = TRUE),dataList)
  finalData<-cbind(mergeLoop[1],rowMeans(mergeLoop[c(-1)],na.rm = TRUE), apply(mergeLoop[c(-1)], 1, sd,na.rm = TRUE))
  colnames(finalData)<- c('distance', 'mean', 'SD')
  return(finalData)
}
mainPipeline<-function(redImg,greenImg,xysize, zsize,xydimSearch,zdimSearch,sampleSize,xyRealDim,zRealDim){
voxCoordsRed<-CorrectSampleVolume(IdVoxel(redImg),xysize, zsize, xydimSearch, zdimSearch)
voxCoordsGreen<-CorrectSampleVolume(IdVoxel(greenImg),xysize, zsize, xydimSearch, zdimSearch)

sampleVoxRed<-SampleVoxels(voxCoordsRed, sampleSize)
sampleVoxGreen<-SampleVoxels(voxCoordsGreen, sampleSize)

distListRR<-LoopVoxels(sampleVoxRed, redImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)
distListRG<-LoopVoxels(sampleVoxRed, greenImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)
distListGR<-LoopVoxels(sampleVoxGreen, redImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)
distListGG<-LoopVoxels(sampleVoxGreen, greenImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)

finalRR<-MergeStats(distListRR)
finalRG<-MergeStats(distListRG)
finalGR<-MergeStats(distListGR)
finalGG<-MergeStats(distListGG)

finalData<-gdata::combine(finalGG,finalRG,finalRR,finalGR)

ggplot()+
  geom_point(data = finalData, aes(x=distance, y = mean, color = source))+
  #geom_errorbar(data = finalData, aes(x=distance, ymin = mean-SD, ymax = mean+SD))
  ggtitle(paste("Search box r (XY=",((((xydimSearch*2)+1)/2)*xyRealDim)," Z=",((((zdimSearch*2)+1)/2)*zRealDim),")", sep = ''))
}
```

```{r secondAnalysisSetup, include= FALSE, echo=FALSE, fig.width=9, fig.height=7, results='asis'}
#The following 4 functions are the second iteration of the pipeline. These functions have a square as the search volume and but the final data include counts over the whole volume of the box and not only the non-empty voxels.
RawBinning<-function(dfDistances, boxVol){#takes the list of pairwise distances between focus and object in box and outputs frequency density table binned by distances of 2 uM
  numDistances<-apply(dfDistances,1,as.numeric)#turn input df into numeric so hist() works
  bins<-seq(0, max(dfDistances)+2,2)#establish the binning
  histogram<-hist(numDistances, breaks = bins, plot = FALSE)
  histCounts<-as.data.frame(histogram$counts)#these are the raw counts per bin
  histDensity<-as.data.frame(histogram$counts/length(numDistances))#these are the proportion of counts over non-empty pixels
  histDensityFunction<-as.data.frame(histogram$density*2)#these are the same as the top but using the function from hist class
  histProportion<-as.data.frame(histogram$counts/boxVol)#these are the proportion of counts over all pixels in box
  finalData<-cbind(histogram$mids, histCounts, histDensity, histDensityFunction, histProportion)
  colnames(finalData)<- c('distance', 'counts', 'normDensity', "funcDensity", "rawDensity")
  return(finalData)
  #return(numDistances)
}
RawLoopVoxels<-function(voxelsList, thresholdedImage, xyBoxDim, zBoxDim, xyScale, zScale ){
  loopBox<-list()
  boxVolum<-((xyBoxDim*2)+1)*((xyBoxDim*2)+1)*((zBoxDim*2)+1)
  for (i in 1:length(voxelsList[[1]])){
    loopBox[[i]]<-RawBinning(DistanceBox(voxelsList[i,],thresholdedImage, xyBoxDim, zBoxDim, xyScale, zScale), boxVolum)
  }
  return(loopBox)
}
RawMergeStats<-function(dataList){
RbindRawMergeLoopAll<-Reduce(function(dtf1,dtf2) rbind(dtf1,dtf2),dataList)
RbindRawMergeLoopAll%>%group_by(distance)%>%summarise(meanCounts=mean(counts),normDensity=mean(normDensity),funcDensity=mean(funcDensity),rawDensity=mean(rawDensity))%>% as.data.frame()->finalData
return(finalData)
}
rawPipeline<-function(redImg,greenImg,xysize, zsize,xydimSearch,zdimSearch,sampleSize,xyRealDim,zRealDim){
voxCoordsRed<-CorrectSampleVolume(IdVoxel(redImg),xysize, zsize, xydimSearch, zdimSearch)
voxCoordsGreen<-CorrectSampleVolume(IdVoxel(greenImg),xysize, zsize, xydimSearch, zdimSearch)

sampleVoxRed<-SampleVoxels(voxCoordsRed, sampleSize)
sampleVoxGreen<-SampleVoxels(voxCoordsGreen, sampleSize)

distListRR<-RawLoopVoxels(sampleVoxRed, redImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)
distListRG<-RawLoopVoxels(sampleVoxRed, greenImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)
distListGR<-RawLoopVoxels(sampleVoxGreen, redImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)
distListGG<-RawLoopVoxels(sampleVoxGreen, greenImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)

finalRR<-RawMergeStats(distListRR)
finalRG<-RawMergeStats(distListRG)
finalGR<-RawMergeStats(distListGR)
finalGG<-RawMergeStats(distListGG)

finalData<-gdata::combine(finalGG,finalRG,finalRR,finalGR)

ggplot()+
  geom_point(data = finalData, aes(x=distance, y = rawDensity, color = source))+
  #geom_errorbar(data = finalData, aes(x=distance, ymin = mean-SD, ymax = mean+SD))
  ggtitle(paste("Search box r (XY=",((((xydimSearch*2)+1)/2)*xyRealDim)," Z=",((((zdimSearch*2)+1)/2)*zRealDim),")", sep = ''))
}
```

```{r thirdAnalysisSetup, include= FALSE, echo=FALSE, fig.width=9, fig.height=7, results='asis'}
#The following 6 functionS are the third iteration of the pipeline. These functions have a spherical 
HollowSphereVolume<-function(r1,r2){
  volume1<-4/3*pi*(r1^3)
  volume2<-4/3*pi*(r2^3)
  return(volume2-volume1)
}
SpherePropOcc<-function(binsList, frequencyList, voxelSize){
  propOcc<-array(0,length(frequencyList))
  for (i in 1:length(frequencyList)){
    propOcc[i]<-frequencyList[i]*voxelSize/HollowSphereVolume(binsList[i],binsList[i+1])
    }
  return(propOcc)
}
RawBinningNorm<-function(dfDistances, boxVol, binSize, voxelVol){#takes the list of pairwise distances between focus and object in box and outputs frequency density table binned by distances of "binSize" in microns
  numDistances<-apply(dfDistances,1,as.numeric)#turn input df into numeric so hist() works
  bins<-seq(0, max(dfDistances)+binSize,binSize)#establish the binning criteria
  histogram<-hist(numDistances, breaks = bins, plot = FALSE)
  histCounts<-as.data.frame(histogram$counts)#these are the raw counts per bin
  histDensity<-as.data.frame(histogram$counts/length(numDistances))#these are the proportion of counts over non-empty pixels
  histDensityFunction<-as.data.frame(histogram$density*binSize)#these are the same as the top but using the function from hist class
  histProportion<-as.data.frame(histogram$counts/boxVol)#these are the proportion of counts over all pixels in box
  histNormSphereBinning<-as.data.frame(SpherePropOcc(bins,histogram$counts,voxelVol))
  finalData<-cbind(histogram$mids, histCounts, histDensity, histDensityFunction, histProportion, histNormSphereBinning)
  colnames(finalData)<- c('distance', 'counts', 'normDensity', "funcDensity", "rawDensity", "normSphereDensity")
  return(finalData)
  }
NormRawLoopVoxels<-function(voxelsList, thresholdedImage, xyBoxDim, zBoxDim, xyScale, zScale, loopBinSize ){
  loopBox<-list()
  radius<-((xyBoxDim*2)+1)/2
  sphereVolum<-4/3*(radius^3)
  voxelVolum<-xyScale*xyScale*zScale
  for (i in 1:length(voxelsList[[1]])){
    distanceList<-DistanceRadius(voxelsList[i,],thresholdedImage, xyBoxDim, zBoxDim, xyScale, zScale)
    if(nrow(distanceList)>0){#this prevents code from breaking if there are no pixels in vecinity
      loopBox[[i]]<-RawBinningNorm(distanceList, sphereVolum,loopBinSize, voxelVolum)
      }
    }
  return(loopBox)
  }
NormRawMergeStats<-function(dataList){
RbindRawMergeLoopAll<-Reduce(function(dtf1,dtf2) rbind(dtf1,dtf2),dataList)
RbindRawMergeLoopAll%>%group_by(distance)%>%summarise(meanCounts=mean(counts),normDensity=mean(normDensity),funcDensity=mean(funcDensity),rawDensity=mean(rawDensity), normPropOccup=mean(normSphereDensity))%>% as.data.frame()->finalData
return(finalData)
}
NormRawPipeline<-function(redImg,greenImg,xysize,zsize,xydimSearch,zdimSearch,sampleSize,xyRealDim,zRealDim, pipeBinSize){
voxCoordsRed<-CorrectSampleVolume(IdVoxel(redImg),xysize, zsize, xydimSearch, zdimSearch)
voxCoordsGreen<-CorrectSampleVolume(IdVoxel(greenImg),xysize, zsize, xydimSearch, zdimSearch)

sampleVoxRed<-SampleVoxels(voxCoordsRed, sampleSize)
sampleVoxGreen<-SampleVoxels(voxCoordsGreen, sampleSize)

distListRR<-NormRawLoopVoxels(sampleVoxRed, redImg, xydimSearch, zdimSearch, xyRealDim, zRealDim, pipeBinSize)
distListRG<-NormRawLoopVoxels(sampleVoxRed, greenImg, xydimSearch, zdimSearch, xyRealDim, zRealDim, pipeBinSize)
distListGR<-NormRawLoopVoxels(sampleVoxGreen, redImg, xydimSearch, zdimSearch, xyRealDim, zRealDim, pipeBinSize)
distListGG<-NormRawLoopVoxels(sampleVoxGreen, greenImg, xydimSearch, zdimSearch, xyRealDim, zRealDim, pipeBinSize)

finalRR<-NormRawMergeStats(distListRR)
finalRG<-NormRawMergeStats(distListRG)
finalGR<-NormRawMergeStats(distListGR)
finalGG<-NormRawMergeStats(distListGG)

finalData<-gdata::combine(finalGG,finalRG,finalRR,finalGR)

ggplot()+
  geom_point(data = finalData, aes(x=distance, y = rawDensity, color = source))+
  #geom_errorbar(data = finalData, aes(x=distance, ymin = mean-SD, ymax = mean+SD))
  ggtitle(paste("Density in search box r (XY=",((((xydimSearch*2)+1)/2)*xyRealDim)," Z=",((((zdimSearch*2)+1)/2)*zRealDim),")", sep = ''))

ggplot()+
  geom_point(data = finalData, aes(x=distance, y = normPropOccup, color = source))+
  #geom_errorbar(data = finalData, aes(x=distance, ymin = mean-SD, ymax = mean+SD))
  ggtitle(paste("Density in search box r (XY=",((((xydimSearch*2)+1)/2)*xyRealDim)," Z=",((((zdimSearch*2)+1)/2)*zRealDim),")", sep = ''))
}

```
## Test Area
```{r test Area, include= FALSE, eval=FALSE, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}

#Image pixels go from 113 to 144
testImage <- array(0, c(256, 256, 9))
testImage[,,1]<-readTiff("square.tiff")@red
testImage[,,2] <-readTiff("square.tiff")@red
testImage[,,3] <-readTiff("square.tiff")@red
testImage[,,4] <-readTiff("square.tiff")@red
testImage[,,5] <-readTiff("square.tiff")@red
testImage[,,6] <-readTiff("square.tiff")@red
testImage[,,7] <-readTiff("square.tiff")@red
testImage[,,8] <-readTiff("square.tiff")@red
testImage[,,9] <-readTiff("square.tiff")@red

xysize<-256
zsize<-9

xydimSearch<-10
zdimSearch<-4
boxVolume<-((xydimSearch*2)+1)*((xydimSearch*2)+1)*((zdimSearch*2)+1)

xyRealDim<-2
zRealDim<-5

sampleSize<-100

testImageCoords <- IdVoxel(testImage)
correctedTestImageCoords<-CorrectSampleVolume(testImageCoords, xysize, zsize, xydimSearch, zdimSearch)
testSampleVoxels<-SampleVoxels(correctedTestImageCoords, sampleSize)
testLoopVoxels<-LoopVoxels(testSampleVoxels, testImage, xydimSearch, zdimSearch, xyRealDim, zRealDim)
testMergeStats<-MergeStats(testLoopVoxels)

testDistanceBox1<-DistanceBox(testSampleVoxels[1,],testImage, xydimSearch, zdimSearch,xyRealDim,zRealDim)
testDistanceBox2<-DistanceBox(testSampleVoxels[2,],testImage, xydimSearch, zdimSearch,xyRealDim,zRealDim)
testDistanceBox3<-DistanceBox(testSampleVoxels[3,],testImage, xydimSearch, zdimSearch,xyRealDim,zRealDim)

#Tests for new binning function
testRawBinning1<-RawBinning(testDistanceBox1, boxVolume)
testRawBinning2<-RawBinning(testDistanceBox2, boxVolume)
testRawBinning3<-RawBinning(testDistanceBox3, boxVolume)

testRawLoopVoxels<-RawLoopVoxels(testSampleVoxels, testImage, xydimSearch, zdimSearch, xyRealDim, zRealDim) 
testRbindRawMergeLoopAll<-Reduce(function(dtf1,dtf2) rbind(dtf1,dtf2),testRawLoopVoxels)
testRbindRawMergeLoopAll%>%group_by(distance)%>%summarise(meanCounts=mean(counts),normDensity=mean(normDensity),funcDensity=mean(funcDensity),rawDensity=mean(rawDensity))%>% as.data.frame()->testSummarize

#Tests for original binning function
testBinning1<-Binning(testDistanceBox1)
testBinning2<-Binning(testDistanceBox2)
testBinning3<-Binning(testDistanceBox3)
testListBinning<-list()
testListBinning[[1]]<- testBinning1
testListBinning[[2]]<- testBinning2
testListBinning[[3]]<- testBinning3

#this is to test function "MergeStats" individually
testMergeLoop<-Reduce(function(dtf1,dtf2) merge(dtf1,dtf2, by= "histogram$mids",all = TRUE),testLoopVoxels)
finalData<-cbind(testMergeLoop[1],rowMeans(testMergeLoop[c(-1)],na.rm = TRUE), apply(testMergeLoop[c(-1)], 1, sd,na.rm = TRUE))
colnames(finalData)<- c('distance', 'mean', 'SD')

#this is to test distance from the central voxel specific voxel
testSquareCenter<-data.frame(c(128),c(128),c(5))
colnames(testSquareCenter)<-c("x", "y","z")
testDistanceBoxCenter<-DistanceBox(testSquareCenter[1,],testImage, xydimSearch, zdimSearch,xyRealDim,zRealDim)
testDistanceRadiusCenter<-DistanceRadius(testSquareCenter[1,],testImage, xydimSearch, zdimSearch,xyRealDim,zRealDim)
testRawBinningCenter<-RawBinning(testDistanceRadiusCenter, boxVolume)
ggplot()+
  geom_point(data = testRawBinningCenter, aes(x=distance, y = counts))

#This tests the SpherePropOcc function
testBinsList<-seq(0, 22,2)
testSpherePropOcc<-SpherePropOcc(testBinsList, testRawBinningCenter[2], 20)
#this is to test the third generation pipeline

greenImgInput<-thresholdImage(c1_files,"green", 512)
redImgInput<-thresholdImage(c2_files,"red", 512)


testVoxCoordsRed<-CorrectSampleVolume(IdVoxel(redImgInput),xytotal = 512, ztotal = 12, xydim=13, zdim=4)
testVoxCoordsGreen<-CorrectSampleVolume(IdVoxel(greenImgInput),xytotal = 512, ztotal = 12, xydim=13, zdim=4)
testSampleVoxRed<-SampleVoxels(testVoxCoordsRed, sampleSize=1000)
testSampleVoxGreen<-SampleVoxels(testVoxCoordsGreen, sampleSize=1000)

testDistListRG<-NormRawLoopVoxels(testSampleVoxRed, greenImgInput, xyBoxDim=13, zBoxDim=4, xyScale = 1.24, zScale = 4, loopBinSize = 2)
testDistListGR<-NormRawLoopVoxels(testSampleVoxGreen, redImgInput, xyBoxDim=13, zBoxDim=4, xyScale = 1.24, zScale = 4, loopBinSize = 2)
testDistListGG<-NormRawLoopVoxels(testSampleVoxGreen, greenImgInput, xyBoxDim=13, zBoxDim=4, xyScale = 1.24, zScale = 4, loopBinSize = 2)
testDistListRR<-NormRawLoopVoxels(testSampleVoxRed, redImgInput, xyBoxDim=13, zBoxDim=4, xyScale = 1.24, zScale = 4, loopBinSize = 2)

#this is for the norm bin function
testRawBinningNorm<-RawBinningNorm(testDistanceRadiusCenter, boxVolume, 2)

```


## Sg Abscess #1.1    
```{r wt sg 1.1, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}

setwd("~/Dropbox (Whiteley Lab)/BrownWhiteleyShare/TIFF Conversions (Unedited)/Asbcess Confocal (10-18-13)/Unedited TIFF Conversions/Z Aa Wt + Sg Abscess #1.1")
parent <- getwd()
files <- dir(parent, recursive = T)
tif <- files[grep("tif", files)]
# split into channels
c1_files <- tif[grep("c1", tif)]
c2_files <- tif[grep("c2", tif)]

greenImgInput<-thresholdImage(c1_files,"green", 512)
redImgInput<-thresholdImage(c2_files,"red", 512)

rawPipeline(redImgInput,greenImgInput,xysize=512, zsize=13,xydimSearch=13,zdimSearch=4,sampleSize=100,xyRealDim=1.24,zRealDim=4)
rawPipeline(redImgInput,greenImgInput,xysize=512, zsize=13,xydimSearch=10,zdimSearch=3,sampleSize=100,xyRealDim=1.24,zRealDim=4)
mainPipeline(redImgInput,greenImgInput,xysize=512, zsize=13,xydimSearch=13,zdimSearch=4,sampleSize=100,xyRealDim=1.24,zRealDim=4)
mainPipeline(redImgInput,greenImgInput,xysize=512, zsize=13,xydimSearch=10,zdimSearch=3,sampleSize=100,xyRealDim=1.24,zRealDim=4)

```

## Sg Abscess #1.2    
```{r wt sg 1.2, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}

setwd("~/Dropbox (Whiteley Lab)/BrownWhiteleyShare/TIFF Conversions (Unedited)/Asbcess Confocal (10-18-13)/Unedited TIFF Conversions/Z Aa Wt + Sg Abscess #1.2")
parent <- getwd()
files <- dir(parent, recursive = T)
tif <- files[grep("tif", files)]
# split into channels
c1_files <- tif[grep("c1", tif)]
c2_files <- tif[grep("c2", tif)]

greenImgInput<-thresholdImage(c1_files,"green", 512)
redImgInput<-thresholdImage(c2_files,"red", 512)

rawPipeline(redImgInput,greenImgInput,xysize=512, zsize=18,xydimSearch=13,zdimSearch=4,sampleSize=100,xyRealDim=1.24,zRealDim=4)
rawPipeline(redImgInput,greenImgInput,xysize=512, zsize=18,xydimSearch=10,zdimSearch=3,sampleSize=100,xyRealDim=1.24,zRealDim=4)
mainPipeline(redImgInput,greenImgInput,xysize=512, zsize=18,xydimSearch=13,zdimSearch=4,sampleSize=100,xyRealDim=1.24,zRealDim=4)
mainPipeline(redImgInput,greenImgInput,xysize=512, zsize=18,xydimSearch=10,zdimSearch=3,sampleSize=100,xyRealDim=1.24,zRealDim=4)

```

## Sg Abscess #1.3      
```{r wt sg 1.3, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}

setwd("~/Dropbox (Whiteley Lab)/BrownWhiteleyShare/TIFF Conversions (Unedited)/Asbcess Confocal (10-18-13)/Unedited TIFF Conversions/Z Aa Wt + Sg Abscess #1.3")
parent <- getwd()
files <- dir(parent, recursive = T)
tif <- files[grep("tif", files)]
# split into channels
c1_files <- tif[grep("c1", tif)]
c2_files <- tif[grep("c2", tif)]

greenImgInput<-thresholdImage(c1_files,"green", 512)
redImgInput<-thresholdImage(c2_files,"red", 512)

rawPipeline(redImgInput,greenImgInput,xysize=512, zsize=12,xydimSearch=13,zdimSearch=4,sampleSize=100,xyRealDim=1.24,zRealDim=4)
rawPipeline(redImgInput,greenImgInput,xysize=512, zsize=12,xydimSearch=10,zdimSearch=3,sampleSize=100,xyRealDim=1.24,zRealDim=4)
mainPipeline(redImgInput,greenImgInput,xysize=512, zsize=12,xydimSearch=13,zdimSearch=4,sampleSize=100,xyRealDim=1.24,zRealDim=4)
mainPipeline(redImgInput,greenImgInput,xysize=512, zsize=12,xydimSearch=10,zdimSearch=3,sampleSize=100,xyRealDim=1.24,zRealDim=4)

```

## Other Sg Abscess files from Roman Github tests   
```{r wt sg 1.4, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}

setwd("~/Dropbox (Whiteley Lab)/BrownWhiteleyShare/2014_11_26RomanTIFFs/Experiment #1/wt abscess/wt abscess #1.1")
parent <- getwd()
files <- dir(parent, recursive = T)
tif <- files[grep("tif", files)]
# split into channels
c1_files <- tif[grep("Aa", tif)]
c2_files <- tif[grep("Sg", tif)]

greenImgInput<-thresholdImage(c1_files,"green", 512)
redImgInput<-thresholdImage(c2_files,"red", 512)

rawPipeline(redImgInput,greenImgInput,xysize=512, zsize=13,xydimSearch=25,zdimSearch=6,sampleSize=100,xyRealDim=2.48,zRealDim=10)
rawPipeline(redImgInput,greenImgInput,xysize=512, zsize=13,xydimSearch=12,zdimSearch=3,sampleSize=100,xyRealDim=2.48,zRealDim=10)
mainPipeline(redImgInput,greenImgInput,xysize=512, zsize=13,xydimSearch=25,zdimSearch=6,sampleSize=100,xyRealDim=2.48,zRealDim=10)
mainPipeline(redImgInput,greenImgInput,xysize=512, zsize=13,xydimSearch=12,zdimSearch=3,sampleSize=100,xyRealDim=2.48,zRealDim=10)

```
## Test of bullseye inverse image
```{r wt sg 1.4, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}

setwd("/Users/jupabago/testRstudioGithub/bulls eye inv")
parent <- getwd()
files <- dir(parent, recursive = T)
tif <- files[grep("tif", files)]
# split into channels
c1_files <- tif[grep("Slide", tif)]
c2_files <- tif[grep("Slide", tif)]

greenImgInput<-thresholdImage(c1_files,"green", 300)
redImgInput<-thresholdImage(c2_files,"red", 300)

testImageCoords <- IdVoxel(greenImgInput)
correctedTestImageCoords<-CorrectSampleVolume(testImageCoords, 300, 10, 100, 1)
testSampleVoxels<-SampleVoxels(correctedTestImageCoords, 100)

#this is to test individual voxels
testBullCenter<-data.frame(c(150),c(150),c(5))
colnames(testBullCenter)<-c("x", "y","z")
testDistanceBox1<-DistanceBox(testBullCenter[1,],greenImgInput, 130, 1,1,1)

#Tests for new binning function
testRawBinning1<-RawBinning(testDistanceBox1, 10000)

ggplot()+
  geom_point(data = testRawBinning1, aes(x=distance, y = counts))
  #geom_errorbar(data = finalData, aes(x=distance, ymin = mean-SD, ymax = mean+SD))
  #ggtitle(paste("Search box r (XY=",((((xydimSearch*2)+1)/2)*xyRealDim)," Z=",((((zdimSearch*2)+1)/2)*zRealDim),")", sep = ''))

```

## Test of bullseye image
```{r wt sg 1.4, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}

setwd("/Users/jupabago/testRstudioGithub/bulls eye2")
parent <- getwd()
files <- dir(parent, recursive = T)
tif <- files[grep("tif", files)]
# split into channels
c1_files <- tif[grep("Slide", tif)]
c2_files <- tif[grep("Slide", tif)]

greenImgInput<-thresholdImage(c1_files,"green", 300)
redImgInput<-thresholdImage(c2_files,"red", 300)

testImageCoords <- IdVoxel(greenImgInput)
correctedTestImageCoords<-CorrectSampleVolume(testImageCoords, 300, 10, 100, 1)
testSampleVoxels<-SampleVoxels(correctedTestImageCoords, 100)

#this is to test individual voxels from the center of the image
testBullCenter<-data.frame(c(150),c(150),c(5))
colnames(testBullCenter)<-c("x", "y","z")
testDistanceBox1<-DistanceBox(testBullCenter[1,],greenImgInput, 130, 1,1,1)

#Tests for new binning function
testRawBinning1<-RawBinning(testDistanceBox1, 10000)

ggplot()+
  geom_point(data = testRawBinning1, aes(x=distance, y = counts))
  #geom_errorbar(data = finalData, aes(x=distance, ymin = mean-SD, ymax = mean+SD))
  #ggtitle(paste("Search box r (XY=",((((xydimSearch*2)+1)/2)*xyRealDim)," Z=",((((zdimSearch*2)+1)/2)*zRealDim),")", sep = ''))

```

## Test Normalized Spherical Proportional Occupancy Wild Type   
Wild-type Aa with three different search volume, 1000 pixels sampled
```{r norm Spherical propo occupancy, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}
setwd("~/Dropbox (Whiteley Lab)/BrownWhiteleyShare/2014_11_26RomanTIFFs/Experiment #1/wt abscess/wt abscess #1.1")
parent <- getwd()
files <- dir(parent, recursive = T)
tif <- files[grep("tif", files)]
# split into channels
c1_files <- tif[grep("Aa", tif)]
c2_files <- tif[grep("Sg", tif)]

greenImgInput<-thresholdImage(c1_files,"green", 512)
redImgInput<-thresholdImage(c2_files,"red", 512)

NormRawPipeline(redImgInput,greenImgInput,xysize=512, zsize=12,xydimSearch=10,zdimSearch=3,sampleSize=11000,xyRealDim=1.24,zRealDim=4, pipeBinSize = 2)
NormRawPipeline(redImgInput,greenImgInput,xysize=512, zsize=12,xydimSearch=13,zdimSearch=4,sampleSize=1000,xyRealDim=1.24,zRealDim=4, pipeBinSize = 2)
NormRawPipeline(redImgInput,greenImgInput,xysize=512, zsize=12,xydimSearch=16,zdimSearch=5,sampleSize=1000,xyRealDim=1.24,zRealDim=4, pipeBinSize = 2)

```
## Test Normalized Spherical Proportional Occupancy DspB
```{r norm Spherical prop occupancy DspB, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}

setwd("~/Dropbox (Whiteley Lab)/BrownWhiteleyShare/2014_11_26RomanTIFFs/Experiment #1/dspB abscess/dspB abscess #1.1")
parent <- getwd()
files <- dir(parent, recursive = T)
tif <- files[grep("tif", files)]
# split into channels
c1_files <- tif[grep("Sg", tif)]
c2_files <- tif[grep("Aa", tif)]

greenImgInput<-thresholdImage(c1_files,"green", 512)
redImgInput<-thresholdImage(c2_files,"red", 512)


NormRawPipeline(redImgInput,greenImgInput,xysize=512, zsize=12,xydimSearch=10,zdimSearch=3,sampleSize=1000,xyRealDim=1.24,zRealDim=4, pipeBinSize = 2)
NormRawPipeline(redImgInput,greenImgInput,xysize=512, zsize=12,xydimSearch=13,zdimSearch=4,sampleSize=1000,xyRealDim=1.24,zRealDim=4, pipeBinSize = 2)
NormRawPipeline(redImgInput,greenImgInput,xysize=512, zsize=12,xydimSearch=16,zdimSearch=5,sampleSize=1000,xyRealDim=1.24,zRealDim=4, pipeBinSize = 2)

```
