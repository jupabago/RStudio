{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Final Romn Based Analysis\"\nauthor: \"Juan P Barraza\"\ndate: \"9/28/2017\"\noutput: html_document\n---\n\n```{r AnalysisSetup, include= FALSE, echo=FALSE, fig.width=9, fig.height=7, results='asis'}\nlibrary(rdist)\nlibrary(pixmap)\nlibrary(rtiff)\nlibrary(reshape2)\nlibrary(gplots)\nlibrary(dplyr)\nlibrary(plyr)\nlibrary(gdata)\nlibrary(ggplot2)\nlibrary(cowplot)\n\n#### 1. THE SETUP\n#### some metadata info needed here\n# what is the xy dimension in pixels\nrm(list = ls())\n\nthresholdImage<-function(filesList,channel,side){\n  c1 <- array(0, c(side, side, length(filesList)))\n  for(i in 1:length(filesList)){\n    print(paste(\"loading ch1...\", i, \"/\", length(filesList), filesList[i]))\n    #c1[,,i]<-readTiff(filesList[i])@green\n    c1[,,i]<-pixmap::getChannels(readTiff(filesList[i]), colors = channel)\n  }\n  c1_t <- array(0, c(side, side, length(filesList)))\n  for(i in 1:dim(c1)[3]){\n    print(paste(\"thresholding ch1...\", i, \"/\", length(filesList), filesList[i]))\n    th <- autoThreshold(c1[,,i], mean(c1[,,i]))[2]\n    c1_t[,,i][c1[,,i] > th] <- 1 \n  }\n  return(c1_t)\n}\n\nCorrectSampleVolume<-function(thresholdedImage, xytotal, ztotal, xydim, zdim){#this limits the boundaries of voxel sampling to prevent going out of bounds\n  correctedImage<- thresholdedImage[  thresholdedImage$x >= xydim & thresholdedImage$x <= (xytotal-xydim) &\n                                        thresholdedImage$y >= xydim & thresholdedImage$y <= (xytotal-xydim) &\n                                        thresholdedImage$z >= zdim & thresholdedImage$z <= (ztotal-zdim),]\n  return(correctedImage)\n}\n\nIdVoxel<-function(thresholdedImage){#this makes a df with the coordinates from all voxel objects\n  dfVoxelCoords <- data.frame(which(thresholdedImage == 1, T))\n  colnames(dfVoxelCoords) <- c(\"x\", \"y\", \"z\")\n  return(dfVoxelCoords)\n}\n\nSampleVoxels<-function(voxelsCoords, sampleSize){#randomly samples non-empty voxels from a thresholded image\n  sampledVoxels <- sample(1:dim(voxelsCoords)[1], size = sampleSize)\n  sampleVoxelsCoords <- voxelsCoords[sampledVoxels,]\n  return(sampleVoxelsCoords)\n}\n\nDistanceBox<-function(focus,thresholdedImage, xydim, zdim, xyscale, zscale){#takes a voxel and collects all the surrounding voxels within the specified box\n  #input of xydim and zdim is in voxels\n  outbox<-thresholdedImage[(focus$x-xydim):(focus$x+xydim), (focus$y-xydim):(focus$y+xydim), (focus$z-zdim):(focus$z+zdim)]\n  outboxCoords<-(IdVoxel(outbox))#find non-empty voxels in box\n  outboxCoords<-outboxCoords-1#move to the orignin\n  outboxCoords$x<-outboxCoords$x*xyscale#convert pixels to real lengths\n  outboxCoords$y<-outboxCoords$y*xyscale\n  outboxCoords$z<-outboxCoords$z*zscale\n  distances<-as.data.frame(t(cdist(t(as.matrix(c(xydim*xyscale, xydim*xyscale, zdim*zscale))), as.matrix(outboxCoords))))\n  return(distances)\n}\n\nBinning<-function(dfDistances){#takes the list of pairwise distances between focus and object in box and outputs frequency density table binned by distances of 2 uM\n  numDistances<-apply(dfDistances,1,as.numeric)#turn input df into numeric so hist() works\n  bins<-seq(0, max(dfDistances)+2,2)#establish the binning\n  histogram<-hist(numDistances, breaks = bins, plot = FALSE)\n  densityTable<-as.data.frame(histogram$density*2)\n  return(cbind(histogram$mids, densityTable))\n}\n\nLoopVoxels<-function(voxelsList, thresholdedImage, xyBoxDim, zBoxDim, xyScale, zScale ){\n  loopBox<-list()\n  for (i in 1:length(voxelsList[[1]])){\n    loopBox[[i]]<-Binning(DistanceBox(voxelsList[i,],thresholdedImage, xyBoxDim, zBoxDim, xyScale, zScale))\n  }\n  return(loopBox)\n}\n\nMergeStats<-function(dataList){\n  mergeLoop<-Reduce(function(dtf1,dtf2) merge(dtf1,dtf2, by= \"histogram$mids\",all = TRUE),dataList)\n  finalData<-cbind(mergeLoop[1],rowMeans(mergeLoop[c(-1)],na.rm = TRUE), apply(mergeLoop[c(-1)], 1, sd,na.rm = TRUE))\n  colnames(finalData)<- c('distance', 'mean', 'SD')\n  return(finalData)\n}\n\nmainPipeline<-function(redImg,greenImg,xysize, zsize,xydimSearch,zdimSearch,sampleSize,xyRealDim,zRealDim){\nvoxCoordsRed<-CorrectSampleVolume(IdVoxel(redImg),xysize, zsize, xydimSearch, zdimSearch)\nvoxCoordsGreen<-CorrectSampleVolume(IdVoxel(greenImg),xysize, zsize, xydimSearch, zdimSearch)\n\nsampleVoxRed<-SampleVoxels(voxCoordsRed, sampleSize)\nsampleVoxGreen<-SampleVoxels(voxCoordsGreen, sampleSize)\n\ndistListRR<-LoopVoxels(sampleVoxRed, redImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)\ndistListRG<-LoopVoxels(sampleVoxRed, greenImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)\ndistListGR<-LoopVoxels(sampleVoxGreen, redImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)\ndistListGG<-LoopVoxels(sampleVoxGreen, greenImg, xydimSearch, zdimSearch, xyRealDim, zRealDim)\n\nfinalRR<-MergeStats(distListRR)\nfinalRG<-MergeStats(distListRG)\nfinalGR<-MergeStats(distListGR)\nfinalGG<-MergeStats(distListGG)\n\nfinalData<-gdata::combine(finalGG,finalRG,finalRR,finalGR)\n\nggplot()+\n  geom_point(data = finalData, aes(x=distance, y = mean, color = source))+\n  #geom_errorbar(data = finalData, aes(x=distance, ymin = mean-SD, ymax = mean+SD))\n  ggtitle(paste(\"Search box r (XY=\",(xydimSearch*xyRealDim),\" Z=\",(zdimSearch*zRealDim),\")\", sep = ''))\n}\n```\n## Sg Abscess #1.1    \n```{r wt sg 1.1, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}\n\nsetwd(\"~/Dropbox (Whiteley Lab)/BrownWhiteleyShare/TIFF Conversions (Unedited)/Asbcess Confocal (10-18-13)/Unedited TIFF Conversions/Z Aa Wt + Sg Abscess #1.1\")\nparent <- getwd()\nfiles <- dir(parent, recursive = T)\ntif <- files[grep(\"tif\", files)]\n# split into channels\nc1_files <- tif[grep(\"c1\", tif)]\nc2_files <- tif[grep(\"c2\", tif)]\n\ngreenImgInput<-thresholdImage(c1_files,\"green\", 512)\nredImgInput<-thresholdImage(c2_files,\"red\", 512)\n\nmainPipeline(redImgInput,greenImgInput,xysize=512, zsize=13,xydimSearch=13,zdimSearch=4,sampleSize=100,xyRealDim=1.24,zRealDim=4)\nmainPipeline(redImgInput,greenImgInput,xysize=512, zsize=13,xydimSearch=10,zdimSearch=3,sampleSize=100,xyRealDim=1.24,zRealDim=4)\n\n```\n\n## Sg Abscess #1.2    \n```{r wt sg 1.2, echo=FALSE, fig.width=4, fig.height=3, results='hide', warning=FALSE}\n\nsetwd(\"~/Dropbox (Whiteley Lab)/BrownWhiteleyShare/TIFF Conversions (Unedited)/Asbcess Confocal (10-18-13)/Unedited TIFF Conversions/Z Aa Wt + Sg Abscess #1.2\")\nparent <- getwd()\nfiles <- dir(parent, recursive = T)\ntif <- files[grep(\"tif\", files)]\n# split into channels\nc1_files <- tif[grep(\"c1\", tif)]\nc2_files <- tif[grep(\"c2\", tif)]\n\ngreenImgInput<-thresholdImage(c1_files,\"green\", 512)\nredImgInput<-thresholdImage(c2_files,\"red\", 512)\n\nmainPipeline(redImgInput,greenImgInput,xysize=512, zsize=18,xydimSearch=13,zdimSearch=4,sampleSize=100,xyRealDim=1.24,zRealDim=4)\nmainPipeline(redImgInput,greenImgInput,xysize=512, zsize=18,xydimSearch=10,zdimSearch=3,sampleSize=100,xyRealDim=1.24,zRealDim=4)\n\n```\n\n",
    "created" : 1506638536351.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "724430288",
    "id" : "AAAC1460",
    "lastKnownWriteTime" : 1506638936,
    "last_content_update" : 1506638936528,
    "path" : "~/Documents/Whiteley/PROJECTS/Proportional Density Analysis scripts/RomanBasedAnalysis.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}